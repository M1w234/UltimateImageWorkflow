import { useState, useRef } from 'react';
import {
  Camera,
  Upload,
  X,
  Loader2,
  Download,
  Plus,
  Trash,
  ChevronDown,
  Folder,
  RefreshCw,
  Copy,
  CheckCircle,
  Zap
} from 'lucide-react';
import { fileToBase64, filterImageFiles, downloadImage, createFilename } from '../utils/imageUtils';
import { generateUniqueId } from '../utils/storage';
import { editImage, buildImageConfig } from '../services/geminiApi';
import { ASPECT_RATIOS, RESOLUTIONS, MAX_SLOTS } from '../utils/constants';
import HistoryPanel from './HistoryPanel';

/**
 * Edit Mode - Single image editing with Gemini
 * Updated layout with collapsible panels and left-right split
 */
export default function EditMode({
  apiKey,
  selectedModel,
  onOpenSettings,
  onAddToCollection,
  onAddToHistory,
  onImageClick,
  playChime,
  // Collection props  
  collection = [],
  collectionOpen = false,
  onCollectionToggle,
  onCollectionClear,
  onCollectionRemove,
  onCollectionDownload,
  onCollectionDownloadAll,
  // History props
  history = [],
  historyOpen = false,
  onHistoryToggle,
  onHistoryClear,
  onHistoryRemove
}) {
  // Image slots state
  const [images, setImages] = useState(
    Array(MAX_SLOTS)
      .fill(null)
      .map((_, idx) => ({
        id: idx,
        image: null,
        imagePreview: null,
        prompt: '',
        aspectRatio: 'auto',
        resolution: '4K',
        variations: 1,
        loading: false,
        result: null,
        results: [],
        error: null,
        fromAnalysis: false
      }))
  );
  const [visibleSlots, setVisibleSlots] = useState(1);

  // Duplicate image state
  const [duplicateImage, setDuplicateImage] = useState(null);
  const [duplicatePreview, setDuplicatePreview] = useState(null);
  const [duplicateCount, setDuplicateCount] = useState(3);
  const [duplicateSectionOpen, setDuplicateSectionOpen] = useState(false);
  const [duplicateDragActive, setDuplicateDragActive] = useState(false);
  const duplicateInputRef = useRef(null);

  // Bulk upload state
  const [bulkSectionOpen, setBulkSectionOpen] = useState(false);
  const [bulkDragActive, setBulkDragActive] = useState(false);
  const fileInputRefs = useRef([]);
  const bulkInputRef = useRef(null);

  // Update a single image slot
  const updateImage = (index, updates) => {
    setImages((prev) =>
      prev.map((img, idx) => (idx === index ? { ...img, ...updates } : img))
    );
  };

  // Handle file input for a slot
  const handleFileInput = async (index, file) => {
    if (!file || !file.type.startsWith('image/')) {
      updateImage(index, { error: 'Please upload an image file' });
      return;
    }

    const { base64, preview } = await fileToBase64(file);
    updateImage(index, {
      image: base64,
      imagePreview: preview,
      error: null,
      result: null,
      results: []
    });
    onAddToCollection(preview, file.name);
  };

  // Remove image from slot
  const removeImage = (index) => {
    updateImage(index, {
      image: null,
      imagePreview: null,
      prompt: '',
      result: null,
      results: [],
      error: null,
      variations: 1
    });
    if (fileInputRefs.current[index]) {
      fileInputRefs.current[index].value = '';
    }
  };

  // Process single image
  const processImage = async (index) => {
    const img = images[index];

    if (!apiKey) {
      onOpenSettings();
      return;
    }

    if (!img.image || !img.prompt.trim()) {
      updateImage(index, { error: 'Please provide both an image and a prompt' });
      return;
    }

    updateImage(index, { loading: true, error: null, results: [] });

    try {
      const imageConfig = buildImageConfig({
        aspectRatio: img.aspectRatio,
        resolution: img.resolution
      });

      // Generate variations
      const promises = Array.from({ length: img.variations }).map(() =>
        editImage({
          apiKey,
          model: selectedModel,
          prompt: img.prompt,
          imageBase64: img.image,
          imageConfig
        })
      );

      const results = await Promise.all(promises);

      // Save to history
      const historyEntry = {
        id: generateUniqueId(),
        timestamp: new Date().toISOString(),
        mode: 'edit',
        prompt: img.prompt,
        sourceImage: img.imagePreview,
        results: results,
        aspectRatio: img.aspectRatio,
        resolution: img.resolution
      };
      onAddToHistory(historyEntry);

      updateImage(index, {
        result: results[0],
        results: results,
        loading: false
      });

      playChime();
    } catch (err) {
      updateImage(index, {
        error: err.message || 'Failed to edit image',
        loading: false
      });
    }
  };

  // Process all images with prompts
  const processAll = async () => {
    const imagesToProcess = images
      .slice(0, visibleSlots)
      .map((img, idx) => ({ ...img, index: idx }))
      .filter((img) => img.image && img.prompt.trim());

    if (imagesToProcess.length === 0) {
      alert('Please add at least one image with a prompt');
      return;
    }

    await Promise.all(imagesToProcess.map((img) => processImage(img.index)));
  };

  // Download handlers
  const handleDownloadImage = (index, variationIdx = 0) => {
    const img = images[index];
    const result = img.results?.[variationIdx] || img.result;
    if (!result) return;
    downloadImage(result, createFilename(`edited-image-${index + 1}`, 'jpg', variationIdx));
  };

  const downloadAllVariations = (index) => {
    const img = images[index];
    if (!img.results || img.results.length === 0) return;
    img.results.forEach((result, varIdx) => {
      setTimeout(() => handleDownloadImage(index, varIdx), varIdx * 200);
    });
  };

  const downloadAll = () => {
    images.slice(0, visibleSlots).forEach((img, idx) => {
      if (img.results && img.results.length > 0) {
        img.results.forEach((result, varIdx) => {
          setTimeout(
            () => handleDownloadImage(idx, varIdx),
            (idx * 10 + varIdx) * 200
          );
        });
      }
    });
  };

  // Bulk upload handlers
  const handleBulkDrag = (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setBulkDragActive(true);
    } else if (e.type === 'dragleave') {
      setBulkDragActive(false);
    }
  };

  const handleBulkDrop = async (e) => {
    e.preventDefault();
    e.stopPropagation();
    setBulkDragActive(false);

    const files = filterImageFiles(e.dataTransfer.files);
    if (files.length === 0) return;

    let availableSlots = images
      .slice(0, visibleSlots)
      .map((img, idx) => ({ ...img, index: idx }))
      .filter((img) => !img.image);

    // Auto-expand if needed
    if (files.length > availableSlots.length) {
      const slotsNeeded = files.length - availableSlots.length;
      const newVisibleSlots = Math.min(MAX_SLOTS, visibleSlots + slotsNeeded);
      setVisibleSlots(newVisibleSlots);

      availableSlots = images
        .slice(0, newVisibleSlots)
        .map((img, idx) => ({ ...img, index: idx }))
        .filter((img) => !img.image);
    }

    const filesToProcess = files.slice(0, availableSlots.length);
    filesToProcess.forEach((file, fileIdx) => {
      if (availableSlots[fileIdx]) {
        handleFileInput(availableSlots[fileIdx].index, file);
      }
    });

    if (files.length > availableSlots.length) {
      alert(
        `Uploaded ${availableSlots.length} images. ${files.length - availableSlots.length} images skipped (max slots).`
      );
    }
  };

  // Duplicate handlers
  const handleDuplicateFile = async (file) => {
    if (!file || !file.type.startsWith('image/')) {
      alert('Please upload an image file');
      return;
    }

    const { base64, preview } = await fileToBase64(file);
    setDuplicateImage(base64);
    setDuplicatePreview(preview);
  };

  const handleDuplicateDrag = (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDuplicateDragActive(true);
    } else if (e.type === 'dragleave') {
      setDuplicateDragActive(false);
    }
  };

  const handleDuplicateDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setDuplicateDragActive(false);

    const file = e.dataTransfer.files[0];
    if (file && file.type.startsWith('image/')) {
      handleDuplicateFile(file);
    }
  };

  const fillDuplicates = () => {
    if (!duplicateImage) {
      alert('Please upload an image first');
      return;
    }

    const currentAvailable = images
      .slice(0, visibleSlots)
      .filter((img) => !img.image).length;

    if (currentAvailable < duplicateCount) {
      const slotsNeeded = duplicateCount - currentAvailable;
      const newVisibleSlots = Math.min(MAX_SLOTS, visibleSlots + slotsNeeded);
      setVisibleSlots(newVisibleSlots);

      setTimeout(() => {
        const availableSlots = images
          .slice(0, newVisibleSlots)
          .map((img, idx) => ({ ...img, index: idx }))
          .filter((img) => !img.image);

        const slotsToFill = Math.min(duplicateCount, availableSlots.length);
        availableSlots.slice(0, slotsToFill).forEach((slot) => {
          updateImage(slot.index, {
            image: duplicateImage,
            imagePreview: duplicatePreview,
            error: null,
            result: null,
            results: []
          });
        });
      }, 50);
      return;
    }

    const availableSlots = images
      .slice(0, visibleSlots)
      .map((img, idx) => ({ ...img, index: idx }))
      .filter((img) => !img.image);

    const slotsToFill = Math.min(duplicateCount, availableSlots.length);
    availableSlots.slice(0, slotsToFill).forEach((slot) => {
      updateImage(slot.index, {
        image: duplicateImage,
        imagePreview: duplicatePreview,
        error: null,
        result: null,
        results: []
      });
    });
  };

  const clearDuplicate = () => {
    setDuplicateImage(null);
    setDuplicatePreview(null);
    if (duplicateInputRef.current) {
      duplicateInputRef.current.value = '';
    }
  };

  // Stats
  const getActiveCount = () =>
    images.slice(0, visibleSlots).filter((img) => img.image && img.prompt.trim()).length;
  const getCompletedCount = () =>
    images.slice(0, visibleSlots).filter((img) => img.results && img.results.length > 0).length;
  const getAvailableSlots = () =>
    images.slice(0, visibleSlots).filter((img) => !img.image).length;

  // Use image from collection
  const useFromCollection = async (collectionImg) => {
    // Find first empty slot
    let targetSlot = images.findIndex((img, idx) => idx < visibleSlots && !img.image);
    
    if (targetSlot === -1) {
      // All slots have images, add new one if possible
      if (visibleSlots < MAX_SLOTS) {
        targetSlot = visibleSlots;
        setVisibleSlots((prev) => prev + 1);
      } else {
        alert('All slots are full. Please clear a slot first.');
        return;
      }
    }

    updateImage(targetSlot, {
      image: collectionImg.base64 || collectionImg.preview,
      imagePreview: collectionImg.preview,
      error: null
    });
  };

  // Filter history for edit-mode only
  const editHistory = history.filter((h) => h.mode === 'edit');

  return (
    <div className="space-y-4">
      {/* TOP SECTION - Three Collapsible Panels */}
      <div className="space-y-3">
        {/* Panel 1: Drop Multiple Images */}
        <div className="border border-slate-700 rounded-lg bg-slate-800/50">
          <button
            onClick={() => setBulkSectionOpen(!bulkSectionOpen)}
            className="w-full px-4 py-3 flex items-center justify-between hover:bg-slate-800/70 transition-colors rounded-lg"
          >
            <div className="flex items-center gap-3">
              <Upload className="w-5 h-5 text-amber-500" />
              <span className="text-white font-medium">Drop Multiple Images</span>
              <span className="text-slate-400 text-sm">Fill slots quickly</span>
            </div>
            <ChevronDown
              className={`w-5 h-5 text-slate-400 transition-transform ${
                bulkSectionOpen ? 'rotate-180' : ''
              }`}
            />
          </button>
          {bulkSectionOpen && (
            <div className="p-4 border-t border-slate-700">
              <div
                className={`border-2 border-dashed rounded-lg p-6 transition-colors ${
                  bulkDragActive
                    ? 'border-amber-500 bg-amber-500/10'
                    : 'border-slate-600'
                }`}
                onDragEnter={handleBulkDrag}
                onDragLeave={handleBulkDrag}
                onDragOver={handleBulkDrag}
                onDrop={handleBulkDrop}
              >
                <input
                  type="file"
                  ref={bulkInputRef}
                  className="hidden"
                  accept="image/*"
                  multiple
                  onChange={(e) => {
                    const files = filterImageFiles(e.target.files);
                    if (files.length > 0) {
                      handleBulkUpload(files);
                    }
                  }}
                />
                <div className="text-center">
                  <Upload className="w-10 h-10 text-amber-500 mx-auto mb-3" />
                  <button
                    onClick={() => bulkInputRef.current?.click()}
                    className="text-amber-400 hover:text-amber-300 font-medium"
                  >
                    Click or drag multiple images here
                  </button>
                  <p className="text-slate-400 text-sm mt-2">
                    Images will be distributed across slots automatically
                  </p>
                </div>
              </div>
            </div>
          )}
        </div>

      {/* Duplicate Image Section */}
      <div>
        <button
          onClick={() => setDuplicateSectionOpen(!duplicateSectionOpen)}
          className="w-full bg-slate-800 hover:bg-slate-750 border border-slate-700 rounded-lg px-4 py-3 flex items-center justify-between transition-all"
        >
          <div className="flex items-center gap-3">
            <RefreshCw className="w-5 h-5 text-green-500" />
            <span className="text-white font-medium">Duplicate Image</span>
            <span className="text-slate-400 text-sm">
              Fill multiple slots with same image
            </span>
          </div>
          <ChevronDown
            className={`w-5 h-5 text-slate-400 transition-transform ${
              duplicateSectionOpen ? 'rotate-180' : ''
            }`}
          />
        </button>

        {duplicateSectionOpen && (
          <div className="mt-2 bg-slate-800/50 border border-slate-700 rounded-lg p-4">
            <div className="flex gap-4 items-start">
              {/* Upload area */}
              <div
                className={`flex-1 border-2 border-dashed rounded-lg p-4 text-center transition-colors ${
                  duplicateDragActive
                    ? 'border-green-500 bg-green-500/10'
                    : 'border-slate-600'
                }`}
                onDragEnter={handleDuplicateDrag}
                onDragLeave={handleDuplicateDrag}
                onDragOver={handleDuplicateDrag}
                onDrop={handleDuplicateDrop}
              >
                <input
                  type="file"
                  ref={duplicateInputRef}
                  className="hidden"
                  accept="image/*"
                  onChange={(e) => {
                    const file = e.target.files?.[0];
                    if (file) handleDuplicateFile(file);
                  }}
                />
                {duplicatePreview ? (
                  <div className="relative inline-block">
                    <img
                      src={duplicatePreview}
                      alt="Duplicate"
                      className="max-h-24 rounded-lg mx-auto"
                    />
                    <button
                      onClick={clearDuplicate}
                      className="absolute -top-2 -right-2 bg-red-500 hover:bg-red-600 text-white p-1 rounded-full"
                    >
                      <X className="w-3 h-3" />
                    </button>
                  </div>
                ) : (
                  <>
                    <Upload className="w-8 h-8 text-green-500 mx-auto mb-2" />
                    <button
                      onClick={() => duplicateInputRef.current?.click()}
                      className="text-green-400 hover:text-green-300 text-sm"
                    >
                      Click or drop image
                    </button>
                  </>
                )}
              </div>

              {/* Controls */}
              <div className="flex flex-col gap-2">
                <div className="flex items-center gap-2">
                  <span className="text-slate-400 text-sm">Fill</span>
                  <input
                    type="number"
                    min="1"
                    max="20"
                    value={duplicateCount}
                    onChange={(e) =>
                      setDuplicateCount(
                        Math.min(20, Math.max(1, parseInt(e.target.value) || 1))
                      )
                    }
                    className="w-16 bg-slate-900 text-white text-center rounded p-2 border border-slate-600"
                  />
                  <span className="text-slate-400 text-sm">slots</span>
                </div>
                <button
                  onClick={fillDuplicates}
                  disabled={!duplicateImage}
                  className="bg-green-500 hover:bg-green-600 disabled:bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors"
                >
                  Fill Slots
                </button>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Image Slots */}
      <div className="space-y-4">
        {images.slice(0, visibleSlots).map((img, index) => (
          <div
            key={img.id}
            className="bg-slate-800/50 rounded-xl p-4 border border-slate-700"
          >
            <div className="flex gap-4">
              {/* Image Upload */}
              <div className="w-32 flex-shrink-0">
                <input
                  type="file"
                  ref={(el) => (fileInputRefs.current[index] = el)}
                  className="hidden"
                  accept="image/*"
                  onChange={(e) => {
                    const file = e.target.files?.[0];
                    if (file) handleFileInput(index, file);
                  }}
                />
                {img.imagePreview ? (
                  <div className="relative">
                    <img
                      src={img.imagePreview}
                      alt="Upload"
                      className="w-32 h-32 object-cover rounded-lg border border-slate-600 cursor-pointer hover:border-amber-500"
                      onClick={() => onImageClick(img.imagePreview, `Image ${index + 1}`)}
                    />
                    <button
                      onClick={() => removeImage(index)}
                      className="absolute -top-2 -right-2 bg-red-500 hover:bg-red-600 text-white p-1 rounded-full"
                    >
                      <X className="w-4 h-4" />
                    </button>
                  </div>
                ) : (
                  <button
                    onClick={() => fileInputRefs.current[index]?.click()}
                    className="w-32 h-32 border-2 border-dashed border-slate-600 rounded-lg flex flex-col items-center justify-center hover:border-amber-500 transition-colors"
                  >
                    <Camera className="w-8 h-8 text-slate-500 mb-2" />
                    <span className="text-slate-400 text-xs">Upload</span>
                  </button>
                )}
              </div>

              {/* Prompt and Options */}
              <div className="flex-1 space-y-3">
                <textarea
                  value={img.prompt}
                  onChange={(e) => updateImage(index, { prompt: e.target.value })}
                  placeholder="Enter your edit prompt..."
                  className="w-full bg-slate-900 text-white rounded-lg p-3 border border-slate-600 focus:border-amber-500 focus:outline-none resize-none h-20 text-sm"
                />

                <div className="flex gap-3 flex-wrap">
                  <select
                    value={img.aspectRatio}
                    onChange={(e) => updateImage(index, { aspectRatio: e.target.value })}
                    className="bg-slate-900 text-white rounded-lg p-2 border border-slate-600 text-sm"
                  >
                    {ASPECT_RATIOS.map((ar) => (
                      <option key={ar.value} value={ar.value}>
                        {ar.label}
                      </option>
                    ))}
                  </select>

                  <select
                    value={img.resolution}
                    onChange={(e) => updateImage(index, { resolution: e.target.value })}
                    className="bg-slate-900 text-white rounded-lg p-2 border border-slate-600 text-sm"
                  >
                    {RESOLUTIONS.map((res) => (
                      <option key={res.value} value={res.value}>
                        {res.label}
                      </option>
                    ))}
                  </select>

                  <div className="flex items-center gap-2">
                    <span className="text-slate-400 text-sm">Variations:</span>
                    <input
                      type="number"
                      min="1"
                      max="5"
                      value={img.variations}
                      onChange={(e) =>
                        updateImage(index, {
                          variations: Math.min(5, Math.max(1, parseInt(e.target.value) || 1))
                        })
                      }
                      className="w-14 bg-slate-900 text-white text-center rounded p-2 border border-slate-600 text-sm"
                    />
                  </div>

                  <button
                    onClick={() => processImage(index)}
                    disabled={img.loading || !img.image || !img.prompt.trim()}
                    className="bg-amber-500 hover:bg-amber-600 disabled:bg-slate-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors flex items-center gap-2"
                  >
                    {img.loading ? (
                      <Loader2 className="w-4 h-4 animate-spin" />
                    ) : (
                      'Generate'
                    )}
                  </button>
                </div>

                {/* Error */}
                {img.error && (
                  <p className="text-red-400 text-sm">{img.error}</p>
                )}
              </div>

              {/* Results */}
              {img.results && img.results.length > 0 && (
                <div className="flex-shrink-0">
                  <p className="text-slate-400 text-xs mb-2">Results</p>
                  <div className="flex gap-2">
                    {img.results.map((result, varIdx) => (
                      <div key={varIdx} className="relative group">
                        <img
                          src={result}
                          alt={`Result ${varIdx + 1}`}
                          className="w-20 h-20 object-cover rounded-lg border border-slate-600 cursor-pointer hover:border-green-500"
                          onClick={() => onImageClick(result, `Result ${varIdx + 1}`)}
                        />
                        <button
                          onClick={() => handleDownloadImage(index, varIdx)}
                          className="absolute bottom-1 right-1 bg-green-500 hover:bg-green-600 text-white p-1 rounded opacity-0 group-hover:opacity-100 transition-opacity"
                        >
                          <Download className="w-3 h-3" />
                        </button>
                      </div>
                    ))}
                  </div>
                  {img.results.length > 1 && (
                    <button
                      onClick={() => downloadAllVariations(index)}
                      className="text-green-400 hover:text-green-300 text-xs mt-1"
                    >
                      Download all
                    </button>
                  )}
                </div>
              )}
            </div>
          </div>
        ))}
      </div>

      {/* Add Slot / Process All */}
      <div className="flex gap-3">
        {visibleSlots < MAX_SLOTS && (
          <button
            onClick={() => setVisibleSlots((prev) => Math.min(MAX_SLOTS, prev + 1))}
            className="flex-1 bg-slate-700 hover:bg-slate-600 text-white font-semibold py-3 rounded-lg transition-colors flex items-center justify-center gap-2"
          >
            <Plus className="w-5 h-5" />
            Add Slot ({visibleSlots}/{MAX_SLOTS})
          </button>
        )}

        <button
          onClick={processAll}
          disabled={getActiveCount() === 0}
          className="flex-1 bg-gradient-to-r from-amber-500 to-orange-500 hover:from-amber-600 hover:to-orange-600 disabled:from-slate-600 disabled:to-slate-600 text-white font-bold py-3 rounded-lg transition-all shadow-lg"
        >
          Process All ({getActiveCount()} ready)
        </button>

        {getCompletedCount() > 0 && (
          <button
            onClick={downloadAll}
            className="bg-green-500 hover:bg-green-600 text-white font-semibold py-3 px-6 rounded-lg transition-colors flex items-center gap-2"
          >
            <Download className="w-5 h-5" />
            Download All
          </button>
        )}
      </div>
    </div>
  );
}
